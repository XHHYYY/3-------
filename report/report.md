# <center> 存储管理问题

[toc]

## <center>动态分区存储管理

## 一、问题描述

​		分区存储管理有固定分区和动态分区两种方法。固定分区把内存划分为若干个固定大小 的连续分区，每个分区的边界固定；而动态分区并不预先将内存事先划分成分区，当程序需 要装入内存时系统从空闲的内存区中，采用不同的分配算法分配大小等于程序所需的内存空 间。它有效地克服了固定分区方式中，由于分区内部剩余内存空置造成浪费的问题。 

​		请基于空闲内存分区链表的存储管理，设计一个动态分区存储管理程序，支持包括首次适配法、下次适配法、最佳适配法和最坏适配法在内的不同分区分配算法。

## 二、实现要求

1. 维护一个记录已分配内存分区和空闲内存分区的链表； 
2. 设计申请、释放函数循环处理用户的请求；
3. 实现首次适配法、下次适配法、最佳适配法和最坏适配法四种分区分配算法； 
4. 可视化展示内存使用情况。

## 三、实验环境

Windows操作系统，使用Python实现。

## 四、具体实现

### 1. 设计思路

​		本实验可以分为三个主要的任务：1. 实现空闲链表数据结构，并完成相关的维护算法，给出程序接口；2. 实现四种分配算法；3. 实现GUI界面，调用相关算法接口和数据结构接口，实现功能。下面针对这三个任务逐一分析。

#### 1. 空闲链表

1. 链表节点表示一个连续的内存块，包含信息有：内存块号、是否空闲、起始位置、内存大小、下一节点。为方便具体实现相关算法这里加入一个新的属性：上一节点。
2. 初始状态，链表除表头外应该只有一个节点，号为0，空闲，起始位置为0，大小默认为1024KB，，下一节点为None，上一节点为head。
3. 运行中可能的操作有：申请内存、释放内存，对象均为某个被上层算法选中的节点。
   1. 申请内存时，传入需要的大小，进行移除判断，通过则将原有的一个空闲节点变为一个指定大小忙碌节点和剩下的空闲节点，返回忙碌节点。
   2. 释放内存时，首先判断该内存是否忙碌，忙碌则根据该节点前后节点空闲情况进行释放，保证释放后没有连续的空闲节点，返回释放后的空闲节点。
4. 考虑到链表节点包含较多信息，这里在`Class.py`中实现了`Memory`类和`process`类，链表节点为`Memory`类的实例，进程信息由`process`类的实例传入，上述算法均实现为`Memory`类的类内方法。

#### 2. 分配算法

1. 首次分配：传入链表首节点`head`，逐一查找是否可分配，是则分配并返回tuple类型变量：(成功，分配后的内存块)，否则返回(失败，`None`)。
2. 下次分配：传入当前链表指针`cur_pointer`，逐一查找是否可分配，是则分配并返回tuple类型变量：(成功，分配后的内存块，当前指针)，否则返回(失败，`None`，`None`)。在调用时需要调用两次。如果第一次不成功可能则传入表头`head`再查找一次。
3. 最佳分配：传入链表首节点`head`，记录一个最佳分配对`tuple: best_pair`，包含(最佳匹配节点，最小内存差)。逐一遍历所有节点并更新最佳匹配对。最后返回tuple类型变量：(成功，分配后的内存块)，或(失败，`None`)。
4. 最差分配：传入链表首节点`head`，记录一个最差分配对`tuple: worst_pair`，包含(最差匹配节点，最大内存差)。逐一遍历所有节点并更新最差匹配对。最后返回tuple类型变量：(成功，分配后的内存块)，或(失败，`None`)。

#### 3. GUI

应当包含的元素有：

- 一个表示内存的空白矩形框，展示当前内存分配情况
- 两个文本输入框`Size`和`Name`，用于表示接下来待分配进程的需要内存大小和进程名，应当对输入做合法性检查并提示。
- 两个按钮`Allocate`和`Free`，用于申请和释放内存， 鼠标按下按钮后可以触发相关函数实现GUI界面的变化，同时修改底层数据结构。
- 鼠标可以点击选择内存块。

### 2. 程序结构与核心代码分析

#### 1. 空闲链表



### 3. 结果验证

### 4. 额外内容

## 五、思考题

​		基于位图和空闲链表的存储管理各有什么优劣？如果使用基于位图的存储管理，有何额 外注意事项？

答：

##### 位图：

优点：

1. 空间利用率高，可以节省内存空间，区分一个内存分配单位是否占用只需要一个1bit标志位；
2. 修改内存分配状态快，效率高，只需修改位图中对应内存的标志位即可；
3. 占据内存空间固定，与进程数无关。

缺点：

1. 需要额外维护一个进程列表与位图中坐标相对应，这样才能在释放进程时修改对应进程占据内存分配单位的标志位。
2. 固定了最小分配单位，如果最小分配单位定义不合适可能：1. 分配单位过小，位图占用内存空间过大，且一个进程可能占据很多的分配单元，修改内存分配状态效率很低（尤其是在分配新内存时需要匹配连续的空闲分配单元，设置过小可能导致匹配性能很差）；2. 分配单位过大，则某些占用内存很少的进程可能不足以占据整个分配单元，导致产生内碎片（同固定分区）。

##### 空闲链表：

优点：

1. 支持任意大小的进程
2. 链表包含了进程信息，因此释放进程时可以直接从表头开始查找到相应进程并释放，无需额外维护进程列表。
3. 占用的内存空间可以动态调整。

空闲链表的存储管理的缺点：

1. 修改内存分配情况速度较慢，涉及多个节点之间指针的修改，同时需要新申请或释放内存以产生或删除节点；
2. 查找速度慢，需要遍历整个链表；
3. 如果有大量占据内存很小的进程，链表长度可能很长，导致查找、修改性能下降，同时占据内存空间较大。

##### 使用基于位图的存储管理的注意事项：

1. 需要针对进程大小分布设计最小分配单元的大小，以避免过小或过大造成的性能影响。
2. 需要考虑数据的更新频率，选择合适的更新策略。

## 六、附录

文件结构

```
pack
│      
├─codes
│     Algorithms.py                     # 实现四种分配算法
│     bridge.py                         # 作为链表系统和GUI系统的中间调度系统
│     Classes.py                        # 实现了内存块Memory类和进程process类
│     CPU.py                            # 实现了内存块具体的调度算法，配合输入队列sequence.txt使用
│     generate_sequence.py              # 生成模拟时序上的内存申请队列
│     GUI.py                            # GUI界面，直接运行即可验证实验任务
│          
└─report
    │  report.md
    │  report.pdf
    └─images

```
